<?php

use phpseclib\Crypt\RSA;

/**
 * JWKMaker
 * Helper to create JWK file
 *
 * A new private key can be generated by using the ocmmand :
 * `openssl genrsa -out filename 2048`
 * 
 * @author Nomura Research Institute, Ltd.
 * @author valÃ©rian Girard <valerian.girard@educagri.fr>
 */
class JOSE_JWKMaker
{

    /**
     * Path to the RSA public/private key
     * @var String
     */
    protected $file_rsa_key;

    /**
     * Unique identifier for JWK
     * 
     * @var String
     */
    protected $kid;

    /**
     * What is the purpose of this JWK :
     *  - sig: signature
     *  - enc: encryption
     * 
     * @var String (sig|enc)
     */
    protected $use;
    
    /**
     * Pass pharse for certificate
     * @var string
     */
    protected $pass_phrase;

    /**
     * 
     * @param string $file_rsa_key
     * @param string $kid
     * @param string $use
     * @param string $pass_phrase
     */
    public function __construct($file_rsa_key, $kid = null, $use = null, $pass_phrase = null)
    {
        $this->file_rsa_key = $file_rsa_key;
        $this->kid = $kid;
        $this->use = $use;
        $this->pass_phrase = $pass_phrase;
    }

    public function makeJwkContent()
    {
        if(!is_file($this->file_rsa_key)) {
            throw new InvalidArgumentException(sprintf("the file %s is a file", $this->file_rsa_key) );
        }
        
        if(!is_readable($this->file_rsa_key)){
            throw new InvalidArgumentException(sprintf("the file %s is not readable", $this->file_rsa_key) );
        }
        
        $cert = file_get_contents($this->file_rsa_key);
        
        $key_pattern = '/(?m)^-----BEGIN (CERTIFICATE|PUBLIC KEY|RSA PRIVATE KEY)-----$\n((?s).*)\n^-----END (CERTIFICATE|PUBLIC KEY|RSA PRIVATE KEY)-----$/';  // matches whole block,

        if (!preg_match($key_pattern, $cert, $matches)) {
            throw new InvalidArgumentException(sprintf("the file %s is not a valid certificate", $this->file_rsa_key) );
        }
        
        $jwk_keys = array();

        if ($matches[1] == 'RSA PRIVATE KEY') {
            $pubinfo = $this->get_mod_exp_from_key($cert, $this->pass_phrase, true);
        } else {
            $pubinfo = $this->get_mod_exp_from_key($cert);
        }

        if ($pubinfo) {
            list($n, $e) = $pubinfo;
            $jwk_key = $this->make_rsa_jwk_key($n, $e);
            if ($jwk_key) {
                $jwk_keys[] = $jwk_key;
            }
        }
        
        $jwk = $this->make_jwk($jwk_keys);
        
        return $jwk;
        
    }

    /**
     * 
     * @param type $n modulus in big endian format
     * @param type $e exponent in big endian format
     * 
     * @return boolean|string JSON
     */
    protected function make_rsa_jwk_key($n, $e)
    {

        if (!$n || !$e) {
            return false;
        }

        $key_info = array('kty' => 'RSA',
            'n' => \JOSE_URLSafeBase64::encode($n),
            'e' => \JOSE_URLSafeBase64::encode($e)
        );
        
        if ($this->kid) {
            $key_info['kid'] = $this->kid;
        }
        if ($this->use) {
            $key_info['use'] = $this->use;
        }

        return $key_info;
    }

    /**
     * 
     * @param type $keys
     * @return type
     */
    protected function make_jwk($keys)
    {
        if (!is_array($keys)) {
            $keys = array($keys);
        }
        
        $jwk = array('keys' => $keys);
        
        return json_encode($jwk);
    }

    protected function get_mod_exp_from_key($key_contents, $pass_phrase = null, $is_private_key = false)
    {

        if ($is_private_key) {
            $key = openssl_pkey_get_private($key_contents, $pass_phrase);
        } else {
            $key = openssl_pkey_get_public($key_contents);
        }


        $rsa = new RSA();

        if (!$rsa) {
            return null;
        }
        
        
        if ($is_private_key) {
            $rsa->setPassword($pass_phrase);
            if (!$rsa->loadKey($key_contents, RSA::PRIVATE_FORMAT_PKCS1)) {
                throw new InvalidArgumentException(sprintf("failed to load key", $this->file_rsa_key) );
            }
        } else {
            $details = openssl_pkey_get_details($key);
            $pubkey = $details['key'];
            if (!$rsa->loadKey($pubkey, RSA::PUBLIC_FORMAT_PKCS1)) {
                return false;
            }
        }
        return array($rsa->modulus->toBytes(), $is_private_key ? $rsa->publicExponent->toBytes() : $rsa->exponent->toBytes());
    }

}
